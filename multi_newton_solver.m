% implementation of newton's method
% 
% INPUTS:
%   fun: the mathematical function for which we want to compute the root
%   note that the output of fun may include the derivative
%   i.e. [fval,dfdx] = fun(x)
%   or not, i.e. fval = fun(x)
%   x_guess the initial guess for Newtonâ€™s method
%   varargin: optional input corresponding to whether or not the solver
%   should use numerical differentation to compute the Jacobian or
%   use a Jacobian generated by fun. No input assumes numerical by default
%   true->fun is assumed to return [fval,J]
%   false->fun is assumed to only return fval
% OUTPUTS:
%   x: the estimate of the root computed by the function
%   define initial guess

function X = multi_newton_solver(fun, x_guess, varargin)

    % true if supposed to use analytical jacobian, false otherwise
    use_analytical_jacobian = nargin == 3 && varargin{1}(1);

    % calculate initial values + step size using approximate Jacobian
    F = fun(x_guess); 
    J = approximate_jacobian(fun, x_guess);
    delta_x = -J\F;
    X = x_guess + delta_x;

    % define threshold
    threshold = 1e-10;

    max_iter = 50;

    count = 0;
    % loop through to find root until below threshold
    while norm(F) > threshold && norm(delta_x) > threshold && count<max_iter
        
        count = count+1;
        F = fun(X);  % update function value

        % check Jacobian determinate is not close to zero
        if det(J*J') < threshold 
            fprintf(['Jacobian determinant is too close to zero. ' ...
                'Exiting...\n']);
            break;
        end

        % change computed output depending on whether anaytical/numerical
        if use_analytical_jacobian

            % if using analytical Jacobian, use fun to return J
            [~, J] = fun(X);

        else

            % otherwise, compute fval and approximate Jacobian numerically
            J = approximate_jacobian(fun, X);
        end

        % calculate step size and update X
        delta_x = -J\F;
        X = X + delta_x;

    end

end